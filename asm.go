package jit

import "unsafe"

// amd64 machine code
var (
	push_rbp      = []byte{0x55}
	push_rax      = []byte{0x50}
	pop_rbp       = []byte{0x5d}
	pop_rax       = []byte{0x58}
	ret           = []byte{0xc3}
	mov_rsp_rbp   = []byte{0x48, 0x89, 0xe5}
	mov_xmm0_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xc0}
	mov_xmm1_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xc8}
	mov_xmm2_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xd0}
	mov_xmm3_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xd8}
	mov_rax_xmm0  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xc0}
	mov_rax_xmm1  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xc8}
	mov_rax_xmm2  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xd0}
	mov_rax_xmm3  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xd8}
	add_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x58, 0xd3}
	mul_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x59, 0xd3}
	sub_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x5c, 0xd3}
	div_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x5e, 0xd3}
)

// mov_imm_rax returns machine code for loading an immediate value in register rax.
// 	movq $x, %rax
func mov_imm_rax(x float64) []byte {
	movabs := []byte{0x48, 0xb8} // movabs ...
	imm := *((*[8]byte)(unsafe.Pointer(&x)))
	return append(movabs, imm[:]...)
}
