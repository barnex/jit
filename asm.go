package main

import (
	"bytes"
	"unsafe"
)

type Buf struct {
	bytes.Buffer
	instr []byte
}

var (
	push_rbp      = []byte{0x55}
	push_rax      = []byte{0x50}
	pop_rbp       = []byte{0x5d}
	pop_rax       = []byte{0x58}
	ret           = []byte{0xc3}
	mov_rsp_rbp   = []byte{0x48, 0x89, 0xe5}
	mov_xmm0_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xc0}
	mov_xmm1_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xc8}
	mov_xmm2_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xd0}
	mov_xmm3_rax  = []byte{0x66, 0x48, 0x0f, 0x7e, 0xd8}
	mov_rax_xmm0  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xc0}
	mov_rax_xmm1  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xc8}
	mov_rax_xmm2  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xd0}
	mov_rax_xmm3  = []byte{0x66, 0x48, 0x0f, 0x6e, 0xd8}
	add_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x58, 0xd3}
	mul_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x59, 0xd3}
	sub_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x5c, 0xd3}
	div_xmm3_xmm2 = []byte{0xf2, 0x0f, 0x5e, 0xd3}
)

func (b *Buf) emit(ops ...[]byte) {
	for _, op := range ops {
		b.Write(op)
	}
}

func cat(ops ...[]byte) []byte {
	var cat []byte
	for _, op := range ops {
		cat = append(cat, op...)
	}
	return cat
}

// load immediate x into rax
func mov_imm_rax(x float64) []byte {
	movabs := []byte{0x48, 0xb8} // movabs ...
	imm := *((*[8]byte)(unsafe.Pointer(&x)))
	return cat(movabs, imm[:])
}
